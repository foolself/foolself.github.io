[{"title":"P5-js-用它来写-html-动画吧","date":"2015-12-13T06:25:23.000Z","path":"2015/12/13/P5-js-用它来写-html-动画吧/","text":"之前是玩过一段时间 processing 的，它就像一个 java 的一个库，很强大的一个库，可以做动画，处理图片，玩 3D 建模 and so on，当然我只是学了一点皮毛，是在学习 python，java 之前。 那今天看到一个新鲜的玩意：P5.js 像写 processing 一样写 javascript 动画 官网：http://p5js.org/ 照着这做： Get started ：http://p5js.org/get-started/ 先创建一个 html 文件，接着在此文件中引入 P5.js 库：1&lt;script src=\"http://cdnjs.cloudflare.com/ajax/libs/p5.js/0.4.20/p5.js\"&gt;&lt;/script&gt; 然后，创建一个 sketch.js 文件，这样写：1234567function setup() &#123;&#125;function draw() &#123; ellipse(50, 50, 80, 80);&#125; 在 html 文件中引用这个 js 文件：1&lt;script type=\"text/javascript\" src=\"sketch.js\"&gt;&lt;/script&gt; 好了，用浏览器打开 html 文件就可以看到用 P5.js 在页面上画了个圆。具体语法，要看一下这：https://github.com/processing/p5.js/wiki/Processing-transition额，这个例子太简单了，也不会动啊！！！好，自己写一个吧：1234567891011121314151617181920212223242526272829303132333435363738var x = 15;var y = 15;var r = 30;var speedX = 2.8;var speedY = 5;function setup() &#123; createCanvas(400, 300);&#125;function draw() &#123; background(200); fill(30, 144, 255); noStroke(); move(width, height); ellipse(x, y, r, r);&#125;function move(width, height) &#123; x += speedX; y += speedY; if (x &gt; width - 15) &#123; speedX *= -1; x = width - 15; &#125;; if (y &gt; height - 15) &#123; speedY *= -1; y = height - 15; &#125;; if (x &lt; 15) &#123; speedX *= -1; x = 15; &#125;; if (y &lt; 15) &#123; speedY *= -1; y = 15; &#125;;&#125;","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://foolself.github.io/tags/js/"},{"name":"processing","slug":"processing","permalink":"https://foolself.github.io/tags/processing/"}]},{"title":"ubuntu下用-sublime-text-来编辑运行-processing-程序","date":"2015-12-12T06:26:13.000Z","path":"2015/12/12/ubuntu下用-sublime-text-来编辑运行-processing-程序/","text":"sublime text 太帅了，所以写什么程序都想用它，那，今天捣鼓一下，用它来写 processing。 插件官方地址：processing-sublime. 有详细的步骤了，下面还是分享一下自己的做法吧。 那，开始吧 1，首先要在你的 linux 上装好了 processing，去官网下载压缩包，解压即可123456//下载wget http://download.processing.org/processing-3.0.1-linux64.tgz//解压到 /optsudo tar zxvf processing-3.0.1-linux64.tgz -C /opt///试一下，这样就可以打开了/opt/processing-3.0.1/.processing 设置环境变量两步12export PATH=$PATH:/opt/processing-3.0.1sudo ln -s /opt/processing-3.0.1/processing-java /bin/processing-java 安装 processing-sublime 插件好多种方法安装插件，这里就用最简单的，直接在 sublime text 下搜索安装首先你要确定你安装了 Package-Control如果没有这样做：从菜单 View - Show Console 或者 ctrl + ~ 快捷键，调出 console，输入以下代码，回车1import urllib.request,os; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), 'wb').write(urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ','%20')).read()) 然后既可以用 Package-Control 来安装插件了Ctrl + Shift + P，搜 processing ，安装。好了，大功告成！现在就写 processing 程序吧。写一个测试程序吧，123void setup()&#123; size(600, 600);&#125; 保存为 .pde 文件，tools 中选择 processing，Ctrl + B，编译运行。 这，，，好像出了问题，大概这和 java 编译有关吧，需要把文件放在和文件名一样的文件夹下才能正确编译了。 去试试吧。","categories":[],"tags":[{"name":"tools","slug":"tools","permalink":"https://foolself.github.io/tags/tools/"}]},{"title":"Java-快排算法的实现","date":"2015-11-19T06:25:08.000Z","path":"2015/11/19/Java-快排算法的实现/","text":"排序思路最经典的排序算法 快排 简介如下： 设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。 具体步骤一趟快速排序的算法是： 设置两个变量i、j，排序开始的时候：i=0，j=N-1；以第一个数组元素作为关键数据，赋值给key，即key=A[0]；从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。 代码实现自己用 Java 动手实践一下。 先来写一次划分的实现：12345678910111213141516171819202122public static int partition(int[] A, int first, int end) &#123; int i = first; int j = end; int temp; while (i &lt; j) &#123; while (i &lt; j &amp;&amp; A[i] &lt;= A[j]) j--; if (i &lt; j) &#123; temp = A[i]; A[i] = A[j]; A[j] = temp; i++; &#125; while (i &lt; j &amp;&amp; A[i] &lt;= A[j]) i++; if (i &lt; j) &#123; temp = A[i]; A[i] = A[j]; A[j] = temp; j--; &#125; &#125; return i; &#125; 然后要想实现整个排序，需要通过下面递归方法：12345678public static void QuickSort(int[] A, int first, int end) &#123; int pivot; if (first &lt; end) &#123; pivot = partition(A, first, end); QuickSort(A, first, pivot - 1); QuickSort(A, pivot + 1, end); &#125;&#125; 好了，算法就是这个样子，Java完整的代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.*;class QuickSortTest &#123; public static void main(String[] args) &#123; int[] A = new int[]&#123;1,5,3,8,0,21,567,9034,6,2&#125;; //初始化待排序数组 for (int e : A) &#123; System.out.print(e + \",\"); //排序前 &#125; QuickSort(A, 0, A.length - 1); //排序 System.out.println(\"\"); for (int e : A)&#123; System.out.print(e + \",\"); //排序后 &#125; &#125; public static int partition(int[] A, int first, int end) &#123; int i = first; int j = end; int temp; while (i &lt; j) &#123; while (i &lt; j &amp;&amp; A[i] &lt;= A[j]) j--; if (i &lt; j) &#123; temp = A[i]; A[i] = A[j]; A[j] = temp; i++; &#125; while (i &lt; j &amp;&amp; A[i] &lt;= A[j]) i++; if (i &lt; j) &#123; temp = A[i]; A[i] = A[j]; A[j] = temp; j--; &#125; &#125; return i; &#125; public static void QuickSort(int[] A, int first, int end) &#123; int pivot; if (first &lt; end) &#123; pivot = partition(A, first, end); QuickSort(A, first, pivot - 1); QuickSort(A, pivot + 1, end); &#125; &#125;&#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://foolself.github.io/tags/java/"}]},{"title":"Django实现文件上传下载（一）","date":"2015-10-23T06:23:33.000Z","path":"2015/10/23/Django实现文件上传下载（一）/","text":"最近在捣鼓 Django 文件上传和下载，过程还好，挺简单，但其中遇到好多问题，折腾好久。把自己实现的方法分享下。 好，先来说上传吧。 参考 Django 官方文档：https://docs.djangoproject.com/en/1.7/topics/http/file-uploads/由于之后还要考虑下载的问题，那我们就多做一步，将文件记录在数据库。 model那么，首先写一个用于记录上传文件的 model ：123class UploadFile(models.Model): name = models.CharField(max_length=50) file = models.FileField(upload_to = \"uploads/%Y/%m\") 其中包含一个 CharField 字段，用于存放上传文件名，还有一个 FileField 字段，用来存放 文件本身（其实是文件的路径）。upload_to 参数是用来设置上传文件的保存路径，此处是按上传日期的年月来归档。 路由配置配置 settings 文件，添加如下两行：12MEDIA_URL = '/media/'MEDIA_ROOT = os.path.join(BASE_DIR, 'media') 如此，文件将上传到 根目录下的 media/uploads/… 下。 接下来写 html 模板 index.html ：1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&#123;% for file in file_list %&#125;&lt;li&gt;&lt;a href=\"#\"&gt;&#123;&#123; file.name &#125;&#125;&lt;/a&gt;&lt;/li&gt;&#123;% endfor %&#125;&lt;form enctype=\"multipart/form-data\" method=\"POST\" action=\"&#123;% url 'uploads' %&#125;\"&gt; &#123;% csrf_token %&#125; &lt;input type=\"file\" name=\"file\" /&gt; &lt;br /&gt; &lt;input type=\"submit\" value=\"上传文件\" /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 配置 URL，urls.py 中添加：12url(r'^$',index),url(r'^uploads', uploads, name =\"uploads\") 后台逻辑接着重点来了，去写具体的方法，views.py ：12345678910111213141516171819202122232425262728293031323334353637def index(request): file_list = UploadFile.objects.all() return render(request, \"index.html\", &#123;\"file_list\" : file_list&#125;)def handle_uploaded_file(f, path):#从路径中提取出 文件名 和 文件所在文件夹路径 t = path.split(\"/\") file_name = t[-1] extensions = file_name.split(\".\")[1] t.remove(t[-1]) t.remove(t[0]) path = \"/\".join(t) try: if not os.path.exists(path): os.makedirs(path) file_name = path + \"/\" + file_name +\".\" + extensions print file_name destination = open(file_name, 'wb+') for chunk in f.chunks(): destination.write(chunk) destination.close() except Exception, e: print e return file_namedef uploads(request): if request.method == 'POST': form = UploadFileForm(request.POST, request.FILES) if form.is_valid(): upload_file = UploadFile.objects.create(name = request.FILES['file'].name, file = request.FILES['file']) #写入数据库 path = upload_file.file.url handle_uploaded_file(request.FILES['file'], path) #上传处理 upload_file.save() #保存 return redirect(\"blog.views.index\") #blog 是 app 名称 else: form = UploadFileForm() return render(request, 'index.html', &#123;'form': form&#125;) 到这按说已经可以了，但，在之后的下载中出了问题，是因为文件名的问题，如果文件名是中文的，在传递的过程中编码的问题就不得不考虑，而且很是烦人，所以在这，我们要避过使用中文文件名的问题。好，查一查，Django 上传文件重命名的问题。 方法来自这：link. 赶紧实践一下。 首先修改settings.py的配置，通过查看源文件，可以看到DEFAULT_FILE_STORAGE默认指向的是FileStorage，我们可以修改指向，然后重写save方法。 settings 文件中添加：1DEFAULT_FILE_STORAGE = \"mysite.customfilefield.storage.FileStorage\" mysite 是工程名，在工程文件夹下新建文件夹 customfilefield ，将下面的 storage.py 文件放在它的下面：1234567891011121314151617181920212223coding:utf-8 -*-from django.core.files.storage import FileSystemStoragefrom django.conf import settingsimport os, timeclass FileStorage(FileSystemStorage): def __init__(self, location=settings.MEDIA_ROOT, base_url=settings.MEDIA_URL): #初始化 super(FileStorage, self).__init__(location, base_url) #重写 _save方法 def _save(self, name, content): #文件扩展名 ext = os.path.splitext(name)[1] #文件目录 d = os.path.dirname(name) #定义文件名，以上传时间命名，像这样的一串数字144557245952 fn = str(time.time()) fn = (\"\").join(fn.split(\".\")) #重写合成文件名 name = os.path.join(d, fn + ext) #调用父类方法 return super(FileStorage, self)._save(name, content) 好了，这样上传的文件的名字就会以上传的时间来命名了。上传就到这里了。","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://foolself.github.io/tags/python/"},{"name":"django","slug":"django","permalink":"https://foolself.github.io/tags/django/"}]},{"title":"Django实现文件上传下载（二）","date":"2015-10-23T06:23:23.000Z","path":"2015/10/23/Django实现文件上传下载（二）/","text":"好，上传了文件，咱们接下来就来下载吧（。。。这么无聊？） 路由配置比起上传，下载要简单点，首先做一下下载的连接，修改 index.html 文件，将待完善的连接写上：1&lt;li&gt;&lt;a href=\"&#123;% url 'blog.views.download' f=file.file.url %&#125;\"&gt;&#123;&#123; file.name &#125;&#125;&lt;/a&gt;&lt;/li&gt; 配置 URL ，添加如下一行：1url(r'^download/(?P&lt;f&gt;.*)$', download, name = \"download\"), 后台逻辑去写 views 方法，views.py 中添加：12345678910111213141516171819202122def download(request, f): t = f.split(\"/\") file_name = t[-1] t.remove(t[-1]) t.remove(t[0]) file_path = \"/\".join(t) def file_iterator(file_name, file_path, chunk_size=512): path = file_path +\"/\" + file_name with open(path) as f: while True: c = f.read(chunk_size) if c: yield c else: break try: response = StreamingHttpResponse(file_iterator(file_name, file_path)) response['Content-Type'] = 'application/octet-stream' response['Content-Disposition'] = 'attachment;filename=\"&#123;0&#125;\"'.format(file_name) except: return HttpResponse(\"Sorry but Not Found the File\") return response 其中涉及到下载文件的分块，因为大文件如果一次性的读入会太占内存。 好了，不出意外的话，上传、下载应该都好了。 最后，还有一个坏消息，如果你的项目和我一样是部署在 SAE 上的，那么，想实现文件上传、下载，这么做还不够，因为需要按照 SAE 的规则来，可以参考 SAE 的官方文档：link.","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://foolself.github.io/tags/python/"},{"name":"django","slug":"django","permalink":"https://foolself.github.io/tags/django/"}]},{"title":"网页中代码高亮","date":"2015-10-10T06:22:40.000Z","path":"2015/10/10/网页中代码高亮/","text":"介绍一款非常轻量级的代码高亮插件Prism下载官网Prism. 下载其中的 css,js 文件，在自己的网页中引入文件123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; ... &lt;link href=\"themes/prism.css\" rel=\"stylesheet\" /&gt;&lt;/head&gt;&lt;body&gt; ... &lt;script src=\"prism.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; ... &lt;link href=\"themes/prism.css\" rel=\"stylesheet\" /&gt;&lt;/head&gt;&lt;body&gt; ... &lt;script src=\"prism.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 引用代码放在 pre,code 标签中，在文本的源代码中, pre 标签中加上class=”language-css”属性 像这样 123&lt;pre class=\"language-python\"&gt;&lt;code&gt;...&lt;/code&gt;&lt;/pre&gt;","categories":[],"tags":[{"name":"htlm","slug":"htlm","permalink":"https://foolself.github.io/tags/htlm/"}]},{"title":"自定义-404-页面","date":"2015-10-08T06:22:54.000Z","path":"2015/10/08/自定义-404-页面/","text":"当我的网站正式发布之后，用户并不都是按照你的意愿去发送各种请求，那么就会经常发生 404，500，403等等错误，这时我们是不希望用户没看到这样的画面的. 所以我们把去设置 setting 文件，debug True 改成 debug False.然后，去自定义错误请求的页面。看一下官方文档：https://docs.djangoproject.com/en/1.8/topics/http/views/在 urls.py 中添加如下代码：1234handler404 = 'blog.views.my_custom_page_not_found_view'handler500 = 'blog.views.my_custom_error_view'handler403 = 'blog.views.my_custom_permission_denied_view'handler400 = 'blog.views.my_custom_bad_request_view' 接着去写每种情况对应的方法，在 views.py 中添加方法：12def my_custom_page_not_found_view(request): return render(request,'404.html') 在 templates 文件夹下新建 404.html 文件，把你想呈现在用户面前的 404 网页写好，搞定了。去测试一下，随便在主页地址后加一个没有的没有定义的地址，转到，结果的确是自己定义的 404 页面。 好，再去访问一下正常的主页，结果，，，你可能发现（你的正常不正常，反正我的是不正常），原来可以正常访问的网页也统统显示刚刚定义 404 页面。这可得了！ 这时看看服务器上可能已经打印了错误的 log ，说是 debug False 的情况下，你必须配置一下1ALLOWED_HOSTS=[] 好，去配置一下，写成这样：1ALLOWED_HOSTS=&quot;*&quot; 这下应该正常了。。。吗？再次打开自己的网站，发现网站样子回到了解放前啊有木有！没有了 css 样式！！！ 很好，如果你也一样遇到了，太好了。这个解决方案有很多，这里我们就来最简单的，停掉 server，这样来运行：1python manage.py runserver --insecure 快看一下，好了，终于恢复正常了。","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://foolself.github.io/tags/python/"},{"name":"django","slug":"django","permalink":"https://foolself.github.io/tags/django/"}]},{"title":"SAE-上部署-Django-应用（三）","date":"2015-09-28T06:24:31.000Z","path":"2015/09/28/SAE-上部署-Django-应用（三）/","text":"后台管理系统admin 需要数据库支持，创建一个本地MySQL数据库（本地需要安装了MySQL服务），要和setting中的名字对应执行同步数据库操作1python manage.py syncdb 同步过程中会让你创建一个 super user，后面登录admin后台管理系统需要 导出数据库，在这推荐可视化数据库管理工具 navicat ，就是下边那个东西，方便导出数据库 同步好数据库后，打开 navicat ，找到刚刚的数据库 myapp，选择右击，转储 sql 文件，登录你的 SAE ，服务管理-&gt;MySQL-&gt;共享性-&gt;管理MySQL-&gt;输入安全密码-&gt;管理MySQL ，看到这个页面： 选择 sql 文件，执行。。。 等等，出错了！！！ WTF。前几个月同样的操作还成功了呢！这里应该是 datetime 吧，之前虽然导入成功，但datetime 类型的字段是读取不出来的，-_-|| 这次则是直接上传失败，网上查解决方案，有位高人之处把 datetime (6) NOT NULL 中的括号部分去掉，然后，真的可以了，嗯，简单粗暴。 这个问题先放一放好了。 好，现在你可以访问 myapp.sinaapp.com/admin/ 了。 创建第一个 app接下来在文件夹 1\\ 下创建第一个 app，叫 blog 吧。1django-admin startapp blog 之后，你的文件树长这样了：123456789101112--1\\ |--blog\\ |--migrations\\ |--__init__.py |--admin.py |--models.py |--views.py |--myapp\\ |--site-packages\\ |--config.yaml |--index.wsgi |--manage.py 接下来写自己的第一个网页吧 myapp 下的 urls.py 添加 url(r’^$’,index), 到 urlpatterns = [ ] 中，还要加上 from blog.views import index现在 urls.py 是这样的：12345678from django.conf.urls import include, urlfrom django.contrib import adminfrom blog.views import indexurlpatterns = [ url(r'^admin/', include(admin.site.urls)), url(r'^$',index),] 现在去 blog 下 views.py 中写 index 方法1234from django.http import HttpResponsedef index(request): return HttpResponse(\"hello django!\") 紧接着同步到 SAE，好，第一个网页就完成了！ 用 SVN 同步到 SAE ，浏览器打开 自己的网站 myapp.sinaapp.com\\ 如果没错你将看到网页上的 “hello django!” 至此，SAE 上部署 Django，正真的完成了，下面自己大展手脚吧！","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://foolself.github.io/tags/python/"},{"name":"django","slug":"django","permalink":"https://foolself.github.io/tags/django/"}]},{"title":"SAE-上部署-Django-应用（二）","date":"2015-09-28T06:24:26.000Z","path":"2015/09/28/SAE-上部署-Django-应用（二）/","text":"部署checkout现在 checkout 到本地 SAE 上的代码 新建一个文件夹，随便你方便的地方，我的叫 myapp，和我应用的名称一样 右击选择 SVN Checkout… 好，这样就将代码 checkout 到本地了，接下来你看到的文件树应该是这样的：12345--myapp |--.svn\\ |--1\\ |--config.yaml |--index.wsgi 创建工程正式开始自己的代码，像往常一样创建 django project1django-admin startproject myapp #myapp就是你的 SAE 上应用名称 接下来，你要把 project 中的文件放到文件夹 1\\ 中，像这样：1234567891011--myapp |--.svn\\ |--1\\ |--config.yaml |--index.wsgi |--manage.py |--myapp\\ |--__init__.py |--settings.py |--urls.py |--wsgi.py 修改配置文件修改 config.yaml、index.wsgi 文件修改 config.yaml、index.wsgi 文件如下： –config.yaml:123456789name: foolselfversion: 1libraries:- name:&quot;django&quot; version:&quot;1.8.4&quot;handlers:- url: /static static_dir: static –index.wsgi:1234import saefrom foolself import wsgiapplication = sae.create_wsgi_app(wsgi.application) 接着修改 myapp 文件夹下的 wsgi.py 文件如下:12345678import osimport sysroot = os.path.dirname(__file__)sys.path.insert(0, os.path.join(root, '..', 'site-packages'))os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"myapp.settings\")from django.core.wsgi import get_wsgi_applicationapplication = get_wsgi_application() 修改 myapp 文件下 setting.py 文件，添加下面内容:123456789101112131415161718192021222324import osBASE_DIR = os.path.dirname(os.path.dirname(__file__))#BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))import os.pathfrom os import environdebug = not environ.get(\"APP_NAME\", \"\") if debug:#LOCAL 本地调试用，便于导出数据库,根据本地MYSQL数据库填写下面参数&lt;----------------如果文件中出现中文，一定要在开始添加 #coding:utf-8 MYSQL_DB = 'foolself' MYSQL_USER = 'root' MYSQL_PASS = '1234' MYSQL_HOST_M = '' MYSQL_HOST_S = '' MYSQL_PORT = '' else: #SAE import sae.const MYSQL_DB = sae.const.MYSQL_DB MYSQL_USER = sae.const.MYSQL_USER MYSQL_PASS = sae.const.MYSQL_PASS MYSQL_HOST_M = sae.const.MYSQL_HOST MYSQL_HOST_S = sae.const.MYSQL_HOST_S MYSQL_PORT = sae.const.MYSQL_PORT 要用MySQL数据库，修改 DATABASES 部分如下:123456789DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': MYSQL_DB, 'USER': MYSQL_USER, 'PASSWORD': MYSQL_PASS, 'HOST': MYSQL_HOST_M, 'PORT': MYSQL_PORT, &#125; 呵，这样整个配置就完成了，够费劲的。 好，现在把更高版本的 django 传到自己的应用中 在文件夹 1/ 下创建文件夹 site-packages/，将自己本地的 django 库复制到新建的文件夹下 像这样：1234--1\\ |--site-packages\\ |--django\\ |--.. commit最后，右击，选择svn commit，选择 ALL，OK，这样就将刚才添加、修改的代码同步到SAE上了 好，至此，你的 django 应用就部署完毕了，打开自己的网址 myapp.sinaapp.com\\ 你应该看到这个熟悉的网页了： 第一次在互联网上访问自己的网站还有点小激动呢 ↖(^ω^)↗","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://foolself.github.io/tags/python/"},{"name":"django","slug":"django","permalink":"https://foolself.github.io/tags/django/"}]},{"title":"SAE-上部署-Django-应用（一）","date":"2015-09-28T06:24:18.000Z","path":"2015/09/28/SAE-上部署-Django-应用（一）/","text":"好，根据自己的实战经历，简单写一下在新浪提供的云计算平台 SAE 上部署自己的 Django 应用。 从头开始。 注册SAE 地址 http://sae.sina.com.cn/ ，新浪微博登录即可。 登录之后，添加应用，这个过程中需要设置一个安全密码，记好了要。 点击 “创建新应用” 按要求填写基本信息，开发语言选择 Python2.7 ，最后点击“创建应用”，OK。 数据库接着初始化一下数据库。服务管理-&gt;MySQL： 选择你需要的类型，就选共享性的好了： 嗯，数据库这就好了。到这你就可以打开自己的网站看一下了，如果你看到“hello SAE”就对了！ 接下来，就是要编写自己的代码了，但我们并不是在线敲自己的代码的。这就需要 SVN 来同步本地代码到 SAE。 关于 SVN 看官网上的介绍 http://www.sinacloud.com/doc/sae/tutorial/code-deploy.html#svn自己装上 SVN ，研究研究。","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://foolself.github.io/tags/python/"},{"name":"django","slug":"django","permalink":"https://foolself.github.io/tags/django/"}]}]